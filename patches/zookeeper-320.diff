diff -ru zookeeper-3.2.0-pristine/src/c/Makefile.in zookeeper-3.2.0/src/c/Makefile.in
--- zookeeper-3.2.0-pristine/src/c/Makefile.in	2009-07-01 12:51:22.000000000 -0400
+++ zookeeper-3.2.0/src/c/Makefile.in	2009-09-03 15:00:41.000000000 -0400
@@ -173,6 +173,7 @@
 zktest_st_OBJECTS = $(nodist_zktest_st_OBJECTS)
 zktest_st_DEPENDENCIES = libzkst.la libhashtable.la \
 	$(am__DEPENDENCIES_1)
+INCLUDES = -I/opt/local/include/ruby1.9-1.9.1 -L/opt/local/lib -L/usr/local/lib
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I.
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
@@ -239,7 +240,7 @@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = -Wall -g
 CYGPATH_W = @CYGPATH_W@
-DEFS = @DEFS@
+DEFS = @DEFS@ -DHAVE_STRUCT_TIMESPEC -DHAVE_SNPRINTF
 DEPDIR = @DEPDIR@
 DOXYGEN_PAPER_SIZE = @DOXYGEN_PAPER_SIZE@
 DSYMUTIL = @DSYMUTIL@
@@ -301,7 +302,7 @@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 LD = @LD@
-LDFLAGS = @LDFLAGS@
+LDFLAGS = @LDFLAGS@ -I/opt/local/include/ruby1.9-1.9.1 -L/opt/local/lib -L/usr/local/lib -lruby1.9
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
diff -ru zookeeper-3.2.0-pristine/src/c/src/zk_hashtable.c zookeeper-3.2.0/src/c/src/zk_hashtable.c
--- zookeeper-3.2.0-pristine/src/c/src/zk_hashtable.c	2009-07-01 12:51:22.000000000 -0400
+++ zookeeper-3.2.0/src/c/src/zk_hashtable.c	2009-08-19 11:56:46.000000000 -0400
@@ -263,12 +263,56 @@
     }
 }
 
+/*  Changes for ruby-zookeeper  *************************************
+**
+**  To work around Ruby's threading peculiarities, we wrap watcher_fn
+**  callback invocations in a ruby thread.
+**
+**  There's probably a better way to do this, and there's certainly a
+**  better way to integrate it into ZK code, but this works and will
+**  do for now.  Patches/suggestions appreciated!
+*/
+
+#include <ruby.h>
+
+typedef struct watcher_data {
+  watcher_fn cb;
+  zhandle_t *zh;
+  int type;
+  int state;
+  char *path;
+  void *ctx;
+  } watcher_data;
+
+static void ruby_wrapper_for_watcher_2(struct watcher_data *w)
+  {
+  w->cb(w->zh,w->type,w->state,w->path,w->ctx);
+  free(w);
+  }
+
+static void ruby_wrapper_for_watcher(watcher_fn cb, zhandle_t *zh, int type,int state, char *path, void *ctx)
+  {
+  struct watcher_data *w;
+
+  w = (watcher_data *)malloc(sizeof(watcher_data));
+  w->cb = (void *)cb;
+  w->zh = zh;
+  w->type = type;
+  w->state = state;
+  w->path = strdup(path);
+  w->ctx = ctx;
+  //printf("   w:0x%08x, cb:0x%08x, path:%s, type:%d, state:%d\n", (unsigned int)w, (unsigned int)w->cb, w->path, w->type, w->state);
+
+  rb_thread_create((void *)ruby_wrapper_for_watcher_2, w);
+  }
+
 static void do_foreach_watcher(watcher_object_t* wo,zhandle_t* zh,
         const char* path,int type,int state)
 {
     char *client_path = sub_string(zh, path);
     while(wo!=0){
-        wo->watcher(zh,type,state,client_path,wo->context);
+        //wo->watcher(zh,type,state,client_path,wo->context);
+        ruby_wrapper_for_watcher(wo->watcher,zh,type,state,client_path,wo->context);
         wo=wo->next;
     }    
     free_duplicate_path(client_path, path);
diff -ru zookeeper-3.2.0-pristine/src/c/src/zookeeper.c zookeeper-3.2.0/src/c/src/zookeeper.c
--- zookeeper-3.2.0-pristine/src/c/src/zookeeper.c	2009-07-01 12:51:22.000000000 -0400
+++ zookeeper-3.2.0/src/c/src/zookeeper.c	2009-09-03 23:56:05.000000000 -0400
@@ -1592,8 +1592,138 @@
     return cptr;
 }
 
+/* Changes for ruby-zookeeper  *************************************
+**
+**  To work around Ruby's threading peculiarities, we wrap callback
+**  invocations in a ruby thread.
+*/
+
+#include <ruby.h>
+
+typedef struct data_completion_data {
+  data_completion_t dc;
+  int rc;
+  char *value;
+  int value_len;
+  struct Stat *stat;
+  void *ctx;
+  } data_completion_data;
+
+static void ruby_wrapper_for_data_completion_2(struct data_completion_data *cb)
+  {
+  LOG_DEBUG(("--- invoking ruby callback.\n\
+-----------------------\n\
+cb->dc         0x%08x\n\
+cb->rc         %d\n\
+cb->value      0x%08x\n\
+cb->value_len  %d\n\
+cb->stat       0x%08x\n\
+cb->ctx        0x%08x\n\
+=======================",
+    cb->dc, cb->rc, cb->value, cb->value_len, cb->stat, cb->ctx));
+  cb->dc(cb->rc, cb->value, cb->value_len, cb->stat, cb->ctx);
+  LOG_DEBUG(("--- callback returned, freeing struct."));
+  free(cb);
+  LOG_DEBUG(("--- struct freed."));
+  }
+
+static void ruby_wrapper_for_data_completion(data_completion_t dc, int rc, void *value, int value_len, void *stat, void *ctx)
+  {
+  struct data_completion_data *cb;
+
+  cb = (data_completion_data *)malloc(sizeof(data_completion_data));
+  cb->dc = dc;
+  cb->rc = rc;
+  cb->value = value ? strdup(value) : 0;
+  cb->value_len = value_len;
+  cb->stat = stat;
+  cb->ctx = ctx;
+
+  LOG_DEBUG(("--- creating ruby thread."));
+  rb_thread_create((void *)ruby_wrapper_for_data_completion_2, cb);
+  }
+
+typedef struct strings_completion_data {
+  strings_completion_t dc;
+  int rc;
+  struct String_vector *strings;
+  void *ctx;
+  } strings_completion_data;
+
+static void ruby_wrapper_for_strings_completion_2(struct strings_completion_data *cb)
+  {
+  LOG_DEBUG(("--- invoking ruby callback.\n\
+-----------------------\n\
+cb->dc              0x%08x\n\
+cb->rc              %d\n\
+cb->strings         0x%08x\n\
+cb->strings->count  %d\n\
+&cb->strings->count 0x%08x\n\
+cb->strings->data   0x%08x\n\
+&cb->strings->data  0x%08x\n\
+*cb->strings->data  0x%08x\n\
+cb->ctx             0x%08x\n\
+=======================",
+    cb->dc, cb->rc, cb->strings, cb->strings->count, &cb->strings->count, cb->strings->data, &cb->strings->data, *cb->strings->data, cb->ctx));
+  cb->dc(cb->rc, cb->strings, cb->ctx);
+  free(cb);
+  }
+
+static void ruby_wrapper_for_strings_completion(strings_completion_t dc, int rc, struct String_vector *strings, void *ctx)
+  {
+  struct strings_completion_data *cb;
+
+  cb = (strings_completion_data *)malloc(sizeof(strings_completion_data));
+  cb->dc = dc;
+  cb->rc = rc;
+  cb->strings = strings;
+  cb->ctx = ctx;
+
+  LOG_DEBUG(("--- creating ruby thread."));
+  rb_thread_create((void *)ruby_wrapper_for_strings_completion_2, cb);
+  }
+
+typedef struct string_completion_data {
+  string_completion_t dc;
+  int rc;
+  char *path;
+  void *ctx;
+  } string_completion_data;
+
+static void ruby_wrapper_for_string_completion_2(struct string_completion_data *cb)
+  {
+  LOG_DEBUG(("--- invoking ruby callback.\n\
+-----------------------\n\
+cb->dc      0x%08x\n\
+cb->rc      %d\n\
+&cb->path   0x%08x\n\
+cb->path    %s\n\
+cb->ctx     0x%08x\n\
+=======================",
+    cb->dc, cb->rc, &cb->path, cb->path, cb->ctx));
+  cb->dc(cb->rc, cb->path, cb->ctx);
+  LOG_DEBUG(("--- callback returned, freeing struct."));
+  free(cb);
+  LOG_DEBUG(("--- struct freed."));
+  }
+
+static void ruby_wrapper_for_string_completion(string_completion_t dc, int rc, char *path, void *ctx)
+  {
+  struct string_completion_data *cb;
+
+  cb = (string_completion_data *)malloc(sizeof(string_completion_data));
+  cb->dc = dc;
+  cb->rc = rc;
+  cb->path = path;
+  cb->ctx = ctx;
+
+  LOG_DEBUG(("--- creating ruby thread"));
+  rb_thread_create((void *)ruby_wrapper_for_string_completion_2, (void *)cb);
+  }
 
 /* handles async completion (both single- and multithreaded) */
+// I think this means we need to wrap completion invocations for
+// both rc cases of each of the six completion types.
 void process_completions(zhandle_t *zh)
 {
     completion_list_t *cptr;
@@ -1619,17 +1749,21 @@
             deallocate_WatcherEvent(&evt);
         } else {
             int rc = hdr.err;
+            LOG_DEBUG(("Switching on cptr->completion_type (async)"));
             switch (cptr->completion_type) {
             case COMPLETION_DATA:
                 LOG_DEBUG(("Calling COMPLETION_DATA for xid=%x rc=%d",cptr->xid,rc));
                 if (rc) {
-                    cptr->c.data_result(rc, 0, 0, 0, cptr->data);
+                    //cptr->c.data_result(rc, 0, 0, 0, cptr->data);
+                    ruby_wrapper_for_data_completion(cptr->c.data_result, rc, 0, 0, 0, (void *)cptr->data);
                 } else {
                     struct GetDataResponse res;
                     deserialize_GetDataResponse(ia, "reply", &res);
-                    cptr->c.data_result(rc, res.data.buff, res.data.len,
-                            &res.stat, cptr->data);
-                    deallocate_GetDataResponse(&res);
+                    //cptr->c.data_result(rc, res.data.buff, res.data.len,
+                    //        &res.stat, cptr->data);
+                    ruby_wrapper_for_data_completion(cptr->c.data_result, rc, res.data.buff, res.data.len, &res.stat, (void *)cptr->data);
+                    // FIXME: handle this in a non-leaky way
+                    //deallocate_GetDataResponse(&res);
                 }
                 break;
             case COMPLETION_STAT:
@@ -1646,23 +1780,30 @@
             case COMPLETION_STRINGLIST:
                 LOG_DEBUG(("Calling COMPLETION_STRINGLIST for xid=%x rc=%d",cptr->xid,rc));
                 if (rc) {
-                    cptr->c.strings_result(rc, 0, cptr->data);
+                    //cptr->c.strings_result(rc, 0, cptr->data);
+                    ruby_wrapper_for_strings_completion(cptr->c.strings_result, rc, 0, (void *)cptr->data);
                 } else {
                     struct GetChildrenResponse res;
                     deserialize_GetChildrenResponse(ia, "reply", &res);
-                    cptr->c.strings_result(rc, &res.children, cptr->data);
-                    deallocate_GetChildrenResponse(&res);
+                    //cptr->c.strings_result(rc, &res.children, cptr->data);
+                    ruby_wrapper_for_strings_completion(cptr->c.strings_result, rc, &res.children, (void *)cptr->data);
+                    // FIXME: deallocate_GetChildrenResponse wipes res before
+                    // ruby reads it.  For now, prefer leaking over failing..
+                    //deallocate_GetChildrenResponse(&res);
                 }
                 break;
             case COMPLETION_STRING:
                 LOG_DEBUG(("Calling COMPLETION_STRING for xid=%x rc=%d",cptr->xid,rc));
                 if (rc) {
-                    cptr->c.string_result(rc, 0, cptr->data);
+                    //cptr->c.string_result(rc, 0, cptr->data);
+                    ruby_wrapper_for_string_completion(cptr->c.string_result, rc, 0, (void *)cptr->data);
                 } else {
                     struct CreateResponse res;
                     deserialize_CreateResponse(ia, "reply", &res);
-                    cptr->c.string_result(rc, res.path, cptr->data);
-                    deallocate_CreateResponse(&res);
+                    //cptr->c.string_result(rc, res.path, cptr->data);
+                    ruby_wrapper_for_string_completion(cptr->c.string_result, rc, res.path, (void *)cptr->data);
+                    // FIXME: leak
+                    //deallocate_CreateResponse(&res);
                 }
                 break;
             case COMPLETION_ACLLIST:
